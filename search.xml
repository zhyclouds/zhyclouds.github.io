<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>未来10年，上班不宜用力过度</title>
      <link href="/2025/06/27/%E6%9C%AA%E6%9D%A510%E5%B9%B4%EF%BC%8C%E4%B8%8A%E7%8F%AD%E4%B8%8D%E5%AE%9C%E7%94%A8%E5%8A%9B%E8%BF%87%E5%BA%A6/"/>
      <url>/2025/06/27/%E6%9C%AA%E6%9D%A510%E5%B9%B4%EF%BC%8C%E4%B8%8A%E7%8F%AD%E4%B8%8D%E5%AE%9C%E7%94%A8%E5%8A%9B%E8%BF%87%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>我们很多人因为从小教育体系规训出来的上进心、责任心、绩优主义，会在活堆到自己身上时自己逼自己去努力把活干好，而且往往会因此活越干越多，但又不一定得到了好的回报。</p><p>很多人上班一旦太认真太用力，就容易因为投入了太多成本而太想要、太想证明自己、太想把事情做好，从而被拿捏、被引导、被PUA…</p><p>这里面的道理，虽然存在一定的局限性，但是确实在时代下行期有一定的适用性。</p><p>这是一个投资回报率的问题。我们作为打工人，在职场投入的最大资本就是时间，而计算收入的性价比最准确的方式是算时薪而不是月薪。</p><p>比如小A同学每天工作8小时，她的月薪是1w，小B同学月薪1.5w，每天工作12个小时，看似小B同学收入比小A同学高，但其实按投入在工作上的时间来算时薪，她俩工资是一样多的。</p><p>那么在这一步，一个职场选择的十字路口就来了——到底是比较佛的小A同学好，还是比较卷的小B同学好？</p><p>我的答案是：在不同的时代周期，和不同的围观环境，你要选择不同的投入回报策略。</p><p>比如说在10年前，整个时代依然在经济上行期的尾部阶段，比如互联网行业还在“上半场”，不管是公司内有大量创新机会，还是行业上有大量创业的公司和机会，再搭配市场上有很多的热钱——只要你把自己时间拼命投入工作，就有大概率能得到超额回报。</p><p>即便是你的公司或上司不给力或与你不匹配，你换一个团队或工作的难度也不大，那如果选择小B同学的卷策略，就会获得更多的回报，为未来积累足够资本——小A的佛策略在这个时期就会拿不到足够多的“放在桌子上的钱”。</p><p>其次，在10年后的今天，时代已经进入了不可避免的下行期，互联网行业也到了被人诟病拼命内卷和歧视年龄的“下半场”。</p><p>这时候你选择卷策略，不仅在时薪收入上占不到便宜，还会因为投入了过多时间成本，而让自己丧失了未来的机会成本——要知道，一份工作需要占用的不仅是你现在投入的时间，还有未来的可能性，因为你没有足够的时间去培养爱好、学习技能、思考生活，为未来的转型升级积累资本。</p><p>试想一下，佛系小A每天能多出4个小时放在自己的爱好、技能、学习上，而卷系小B在时代下行期还在拼命工作，不仅投资回报低效还让身体搞出一身病，那5年甚至10年后，两个人的差距会有多大？</p><p>当然，如果卷系小B在时代下行期依然找到了非常好的赛道或者团队，例如AI算法等工作，或得到了大佬的青睐，那么可以忽略我上面这些话了。</p><p>天地不仁以万物为刍狗，时代有周期人无再少年，如果你恰巧遭遇了不那么好的周期，在这个周期又没有好的工作机遇和志趣相投的团队，那么往后10年的最优解，就是在工作中给别人交付靠谱的工作结果不造成麻烦的情况下，想法设法将更多的时间和精力投入到自己身上，副业也好，爱好也好，技能也好。</p><p>要珍惜沉寂的时光，在沉寂中滋养成长，顺便等待时代的下一次机会。</p><p>原文：<a href="https://m.okjike.com/originalPosts/685cc8feb7f4ddcfdf6bf883?s=eyJ1IjoiNjZmNTg3MzE3ZTY2NDJhNDQxZWQ4YTg2In0=">https://m.okjike.com/originalPosts/685cc8feb7f4ddcfdf6bf883?s=eyJ1IjoiNjZmNTg3MzE3ZTY2NDJhNDQxZWQ4YTg2In0%3D</a></p>]]></content>
      
      
      <categories>
          
          <category> 闲谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go轻框架理论</title>
      <link href="/2025/06/24/go%E8%BD%BB%E6%A1%86%E6%9E%B6%E7%90%86%E8%AE%BA/"/>
      <url>/2025/06/24/go%E8%BD%BB%E6%A1%86%E6%9E%B6%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="go-偏向于轻框架而不是集成度特别高的框架，为什么？"><a href="#go-偏向于轻框架而不是集成度特别高的框架，为什么？" class="headerlink" title="go 偏向于轻框架而不是集成度特别高的框架，为什么？"></a>go 偏向于轻框架而不是集成度特别高的框架，为什么？</h2><ul><li>重框架也就是大型、侵入式框架的缺点<ul><li>学习曲线陡峭</li><li>性能损耗</li><li>不够灵活</li><li>开发者不知道框架底层具体干了些什么</li></ul></li><li>go 自己有强大的标准库，让开发者遇到问题的时候首先向内寻求解决办法，这是其轻框架理念的底气</li><li>go 组合优于继承，接口驱动设计</li><li>轻框架能够让开发者有一种掌控感，知道底层干了什么</li><li>鼓励只针对一个特定问题寻求解决方案，而不是“万能”框架</li></ul><h2 id="go-的轻框架理念又会带来什么问题？"><a href="#go-的轻框架理念又会带来什么问题？" class="headerlink" title="go 的轻框架理念又会带来什么问题？"></a>go 的轻框架理念又会带来什么问题？</h2><ul><li>重复造轮子，功能相似但是实现逻辑不同</li><li>技术选型不知道到底选哪个</li><li>因为灵活自由，各个服务不同开发者实现出来的代码风格、框架选型可能都不一样</li></ul><h2 id="如何避免轻框架理念带来的问题，在自由和规范之间寻找一个平衡点？"><a href="#如何避免轻框架理念带来的问题，在自由和规范之间寻找一个平衡点？" class="headerlink" title="如何避免轻框架理念带来的问题，在自由和规范之间寻找一个平衡点？"></a>如何避免轻框架理念带来的问题，在自由和规范之间寻找一个平衡点？</h2><ul><li>团队文档沉淀</li><li>着重架构设计</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《局外人》读记——6.23</title>
      <link href="/2025/06/23/%E3%80%8A%E5%B1%80%E5%A4%96%E4%BA%BA%E3%80%8B%E8%AF%BB%E8%AE%B0%E2%80%94%E2%80%946-23/"/>
      <url>/2025/06/23/%E3%80%8A%E5%B1%80%E5%A4%96%E4%BA%BA%E3%80%8B%E8%AF%BB%E8%AE%B0%E2%80%94%E2%80%946-23/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 刚刚在夜色中缓缓升起的星星在这灯光下黯然失色。人行道上灯火通明，行人熙熙攘攘，看久了眼睛很累。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《局外人》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go web 框架——初探</title>
      <link href="/2025/06/21/go-web-%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94%E5%88%9D%E6%8E%A2/"/>
      <url>/2025/06/21/go-web-%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="Go-Web-框架自研——初探"><a href="#Go-Web-框架自研——初探" class="headerlink" title="Go Web 框架自研——初探"></a>Go Web 框架自研——初探</h1><h2 id="beego-框架参考"><a href="#beego-框架参考" class="headerlink" title="beego 框架参考"></a>beego 框架参考</h2><p>这是 beego 启动一个 web 服务的基础用法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// controller.go</span></span><br><span class="line"><span class="keyword">package</span> beego</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/beego/beego/v2/server/web&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserController <span class="keyword">struct</span> &#123;</span><br><span class="line">web.Controller</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UserController)</span></span> GetUser() &#123;</span><br><span class="line">u.Ctx.WriteString(<span class="string">&quot;你好，我是小张&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UserController)</span></span> CreateUser() &#123;</span><br><span class="line">user := &amp;User&#123;&#125;</span><br><span class="line">err := u.Ctx.BindJSON(user)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">u.Ctx.WriteString(err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_ = u.Ctx.JSONResp(user)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// controller_test.go</span></span><br><span class="line"><span class="keyword">package</span> beego</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/beego/beego/v2/server/web&quot;</span></span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUserController</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">web.BConfig.CopyRequestBody = <span class="literal">true</span></span><br><span class="line">c := &amp;UserController&#123;&#125;</span><br><span class="line">web.Router(<span class="string">&quot;/user&quot;</span>, c, <span class="string">&quot;get:GetUser&quot;</span>)</span><br><span class="line">web.Router(<span class="string">&quot;/user/create&quot;</span>, c, <span class="string">&quot;post:CreateUser&quot;</span>)</span><br><span class="line">web.Run(<span class="string">&quot;:8081&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，定义了一个 UserController 结构体，这个 controller 组合了 beego 的 web controller，提供了获取用户和创建用户两个方法。然后注册路由的时候把这个 controller 传了进去。</p><p>也就是说，beego 是按照 MVC 模式设计的，它要求使用者在业务层面上使用 MVC 模式组织自己的代码，也就是一个业务一个 controller 这个样子。不过我个人觉得，这种设计不是很好，是否使用 MVC 应该让使用者自己选择，而不应该让框架提供者来左右。</p><p>再来看一下定义 controller 的时候组合的 beego 的 web controller 定义：</p><p><img src="https://zhyclouds.oss-cn-hangzhou.aliyuncs.com/haoyu/image-20250621212626372.png" alt="beego web controller"></p><p>这里有一个 ctx 字段，它的定义是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Context Http request context struct including BeegoInput, BeegoOutput, http.Request and http.ResponseWriter.</span></span><br><span class="line"><span class="comment">// BeegoInput and BeegoOutput provides an api to operate request and response more easily.</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">Input          *BeegoInput</span><br><span class="line">Output         *BeegoOutput</span><br><span class="line">Request        *http.Request</span><br><span class="line">ResponseWriter *Response</span><br><span class="line">_xsrfToken     <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，beego 在 ctx 里面存了请求和响应信息，以及自己的输入输出。我觉得这样有点重复了，很容易让使用者误解，为什么会有两个输入，两个输出，究竟应该使用哪个。</p><p>在启动 web 服务的时候，是直接使用的 web.Run 方法，这是 beego 提供的一个默认包变量，它的定义是：</p><p><img src="https://zhyclouds.oss-cn-hangzhou.aliyuncs.com/haoyu/image-20250621211358355.png" alt="beego server 抽象"></p><p>可以看到，beego 抽象出了一个 server 层面上的结构体，这个结构体里面有一些字段，其中 LifeCycleCallbacks 也就是声明周期回调函数，用户可以控制服务启动前干些什么，启动后干些什么。Server 字段是 http 包里面的 Server 类型，可以用来启动服务。Handlers 字段的类型定义是这样的：</p><p><img src="https://zhyclouds.oss-cn-hangzhou.aliyuncs.com/haoyu/image-20250621212145464.png" alt="controllerRegister"></p><p>这里面有一个 routers 字段，它是一个 map 类型，存的是每个请求方法对应的路由树，用户注册的路由会存到这里面来。</p><p>通过这些，可以看到 beego 基本上有四个抽象：</p><ul><li>路由（这个是最重要的）</li><li>server</li><li>context</li><li>controller</li></ul><p>server 负责把其它抽象组合起来，方便使用者使用，并且负责和 go 的 http 包打交道，在 server 层面上也提供了一些声明周期回调。</p><p>context 主要负责请求响应的传递，以及负责用户自定义的数据传递。</p><p>路由负责匹配请求和对应的业务处理方法。</p><p>controller 则负责业务处理。</p><p>整体样子就是：</p><img src="https://zhyclouds.oss-cn-hangzhou.aliyuncs.com/haoyu/%E7%BB%98%E5%9B%BE1.jpg" alt="beego 抽象" style="zoom: 13%;" /><h2 id="其它框架参考"><a href="#其它框架参考" class="headerlink" title="其它框架参考"></a>其它框架参考</h2><p>其它框架比如说 gin、iris、echo，用法上基本都相似，因为国内用 gin 也比较多嘛，所以这里以 gin 为例说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user_controller.go</span></span><br><span class="line"><span class="keyword">package</span> gin</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserController <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *UserController)</span></span> GetUser(ctx *gin.Context) &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;一些业务错误&quot;</span>)</span><br><span class="line">ctx.String(<span class="number">200</span>, <span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user_controller_test.go</span></span><br><span class="line"><span class="keyword">package</span> gin</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUserController_GetUser</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">g := gin.Default()</span><br><span class="line">ctrl := &amp;UserController&#123;&#125;</span><br><span class="line">g.GET(<span class="string">&quot;/user/info&quot;</span>, ctrl.GetUser)</span><br><span class="line">g.POST(<span class="string">&quot;/user/:param&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">ctx.String(http.StatusOK, <span class="string">&quot;hello %s&quot;</span>, <span class="string">&quot;world&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">_ = g.Run(<span class="string">&quot;:8082&quot;</span>)</span><br><span class="line"></span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:8083&quot;</span>, g)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，和 beego 不同的是 gin 没有按照 MVC 模式设计自己的代码，而是让用户在注册路由的时候，传入一个 <code>func(ctx *gin.Context)</code> 类型的函数，框架将其抽象成了<code>type HandlerFunc func(*Context)</code>。</p><p>这样的好处就是用户可以选择是否使用 MVC 模式来组织自己的代码。如果用户想要使用 MVC 模式，那么只需要按照这个函数类型设计自己的方法就可以了。</p><p>gin 的 Context 也和 beego 类似：</p><p><img src="https://zhyclouds.oss-cn-hangzhou.aliyuncs.com/haoyu/image-20250621220559357.png" alt="gin context"></p><p>至于 beego 的 httpServer，gin 里面是 Engine：</p><p><img src="https://zhyclouds.oss-cn-hangzhou.aliyuncs.com/haoyu/image-20250621220724817.png" alt="gin engine"></p><p>而且 gin 的 Engine，实现了 http 包里面的 Handler 接口：</p><p><img src="https://zhyclouds.oss-cn-hangzhou.aliyuncs.com/haoyu/image-20250621220854842.png" alt="gin engine"></p><p>也就意味着，我可以使用 gin 包提供的启动方法，也可以创建一个 gin 的 Engine，然后使用 http 包里面的 ListenAndServe 启动它。</p><p>然后 Engine 结构体组合了 RouterGroup，其定义为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RouterGroup is used internally to configure router, a RouterGroup is associated with</span></span><br><span class="line"><span class="comment">// a prefix and an array of handlers (middleware).</span></span><br><span class="line"><span class="keyword">type</span> RouterGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">Handlers HandlersChain</span><br><span class="line">basePath <span class="type">string</span></span><br><span class="line">engine   *Engine</span><br><span class="line">root     <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面存在和 Engine 的一个双向引用关系，gin 可能是需要在 RouterGroup 上拿到 engine 进行一些操作。</p><p>对于 gin 的路由注册：</p><p><img src="https://zhyclouds.oss-cn-hangzhou.aliyuncs.com/haoyu/image-20250621221250864.png" alt="gin router"></p><p>可以看到 gin 为不同的请求方法提供了不同的实现，不过最终都会调到 handle 方法上。这里我认为可以只提供一个 Handle 方法，不用提供 GET、POST 等这些实现，这样可以让接口尽可能的小而美。</p><p>可以看到 gin 也差不多设计成了这幅样子：</p><ul><li>Engine</li><li>路由 RouterGroup</li><li>Context</li><li>HandlerFunc</li></ul><p>和 beego 一样，只不过名字不用而已。</p><img src="https://zhyclouds.oss-cn-hangzhou.aliyuncs.com/haoyu/image-20250621221841238.png" alt="gin 抽象" style="zoom:13%;" /><p>其它几个框架类似，这里就不详细说了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以看到这些 web 框架，基本上都是一副鬼样子，有 server、路由、context、业务处理四个抽象。</p><p>server 负责和 go 的 http 包打交道，负责 web 服务的启动终止、生命周期管理，以及将路由注册、业务处理这些抽象组织在一起，方便框架者使用。</p><p>context 负责数据管理，请求响应内容处理。</p><p>业务处理负责组织使用者的业务代码。</p><p>路由注册负责绑定号好不同的请求方法和路径对应的业务处理逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> web 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络IO模型进化史</title>
      <link href="/2025/06/20/%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B%E8%BF%9B%E5%8C%96%E5%8F%B2/"/>
      <url>/2025/06/20/%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B%E8%BF%9B%E5%8C%96%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<p>整个网络 IO 模型的发展是从阻塞 IO开始、中间逐步演变成非阻塞 IO、基于非阻塞 IO 的多路复用模型。其中多路复用又是从 select 发展到 poll 最后到 epoll 形式的。</p><h2 id="阻塞-IO"><a href="#阻塞-IO" class="headerlink" title="阻塞 IO"></a>阻塞 IO</h2><p>就是一直等着，直到拿到数据之后才继续往下执行。<br>客户端和服务端建立好连接之后，服务端读取客户端发送过来的数据。从 <code>read</code> 开始就一直等着，直到读取到数据才返回，继续往下执行。<br>这种方式的缺点就是，一个线程只能处理一个连接。如果我想处理多个客户端的连接，就只能多开线程。虽然线程是轻量的，但是当我有很多个连接的时候，线程开销会非常大。<br>那能不能不让 <code>read</code> 等待呢？能不能调用了之后让它直接返回？这就是非阻塞 IO。</p><h2 id="非阻塞-IO"><a href="#非阻塞-IO" class="headerlink" title="非阻塞 IO"></a>非阻塞 IO</h2><p>首先来看一下服务端是怎么一步一步把数据给到用户态的。</p><ol><li>客户端发送数据给服务端</li><li>网卡收到客户端发来的数据</li><li>网卡等着数据全部发过来之后，将数据拷贝到内核</li><li>内核等着数据拷贝完成后，将数据拷贝给用户态</li><li>用户态等待数据全部拷贝完成<br>整个过程也就是 <strong>客户端 -&gt; 网卡 -&gt; 内核 -&gt; 用户态</strong>。</li></ol><p>那为了能够让 <code>read</code> 直接返回而不用阻塞等待，就可以在数据拷贝到内核之前，直接返回一个是否就绪的状态。如果内核还没有收到全部的数据，就返回一个未就绪的状态，如果数据已经准备好了，就返回一个文件描述符，这样就可以把数据读到用户态了。<br>也就是：</p><ul><li>内核没准备好 return -1</li><li>内核准备好了 return 文件描述符</li></ul><p>这样用户态上就不用一直等着了。怎么根据这个返回值解决一个线程只能处理一个连接的问题呢？<br>我可以维护一个列表，这个列表里面放的是连接对象。然后单独开一个线程，不断轮询这个列表中的连接，当有连接的 <code>read</code> 就绪了就处理，没有就绪就会遍历下一个连接。这样当有新的连接来的时候，就可以直接把这个连接放到列表里面。就实现了一个线程里面处理多个连接的操作。<br>但是这样有什么缺点呢？轮询。当连接非常多的时候，轮询效率是很低的，而且每一次遍历连接，都会执行系统调用，进行用户态和内核态之间的上下文切换，开销很大。<br>既然这样，我干脆把轮询操作放到内核态去，让内核帮我去轮询，多好。于是就有了 IO 多路复用模型。</p><h2 id="基于非阻塞-IO-的多路复用"><a href="#基于非阻塞-IO-的多路复用" class="headerlink" title="基于非阻塞 IO 的多路复用"></a>基于非阻塞 IO 的多路复用</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>将轮询操作放到内核态。用户态只要传一个连接列表给到内核就可以了，内核去轮询连接状态。当某次轮询中有连接就绪后，遍历完然后返回这个列表里面就绪的个数。用户态上依然要去遍历这个连接列表去读数据。这里注意 <code>select</code> 操作是阻塞的，之所以说是基于非阻塞 IO 的多路复用，我觉得是因为它是从非阻塞 IO 的基础上发展来的。</p><p>这样有什么缺点呢？</p><ol><li>复制。要把连接列表复制到内核去，为什么不直接复用呢？复制的话连接很多的时候很消耗性能。</li><li>轮询。内核还是要去轮询。轮询过程是同步的，为什么不改成异步的，当就绪后发送一个事件通知内核？</li><li>select 的返回是就绪个数。为什么不直接返回已经就绪的文件描述符？</li></ol><p>为了解决这些问题，就有了 poll 和 epoll。</p><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>和 select 的主要区别是，去掉了 select 只能监听 1024 个文件描述符的限制。</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>解决了复制、轮询、返回值的问题。</p><ul><li>复制问题：在内核层面上维护一个文件集合，用户层面只需要告诉内核怎么修改这个集合就行了。</li><li>轮询问题：改成了异步事件通知的方式。通过异步 IO 事件唤醒。</li><li>返回值的问题：通过操作一个红黑树结构返回已就绪的文件描述符。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我觉得整个发展历程，就是从原来的只能操作单个连接，变成了批量操作多个连接。<br>而且减少了用户层面上的操作复杂度，虽然到最后用户层面上看起来是同步阻塞的（这种同步是符合人的心智的），但是内核对所有的连接会进行异步处理。<br>减少了系统调用的次数，开销变小。</p><p>这里分享 <a href="https://www.cnblogs.com/flashsun/p/14591563.html">https://www.cnblogs.com/flashsun/p/14591563.html</a> 的一个例子帮助理解。</p><blockquote><p>就好比我们平时写业务代码，把原来 while 循环里调 http 接口进行批量，改成了让对方提供一个批量添加的 http 接口，然后我们一次 rpc 请求就完成了批量添加。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
