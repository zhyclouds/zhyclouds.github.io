<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>go web 框架——初探</title>
      <link href="/2025/06/21/go-web-%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94%E5%88%9D%E6%8E%A2/"/>
      <url>/2025/06/21/go-web-%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="Go-Web-框架自研——初探"><a href="#Go-Web-框架自研——初探" class="headerlink" title="Go Web 框架自研——初探"></a>Go Web 框架自研——初探</h1><h2 id="beego-框架参考"><a href="#beego-框架参考" class="headerlink" title="beego 框架参考"></a>beego 框架参考</h2><p>这是 beego 启动一个 web 服务的基础用法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// controller.go</span></span><br><span class="line"><span class="keyword">package</span> beego</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/beego/beego/v2/server/web&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserController <span class="keyword">struct</span> &#123;</span><br><span class="line">web.Controller</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UserController)</span></span> GetUser() &#123;</span><br><span class="line">u.Ctx.WriteString(<span class="string">&quot;你好，我是小张&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UserController)</span></span> CreateUser() &#123;</span><br><span class="line">user := &amp;User&#123;&#125;</span><br><span class="line">err := u.Ctx.BindJSON(user)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">u.Ctx.WriteString(err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_ = u.Ctx.JSONResp(user)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// controller_test.go</span></span><br><span class="line"><span class="keyword">package</span> beego</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/beego/beego/v2/server/web&quot;</span></span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUserController</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">web.BConfig.CopyRequestBody = <span class="literal">true</span></span><br><span class="line">c := &amp;UserController&#123;&#125;</span><br><span class="line">web.Router(<span class="string">&quot;/user&quot;</span>, c, <span class="string">&quot;get:GetUser&quot;</span>)</span><br><span class="line">web.Router(<span class="string">&quot;/user/create&quot;</span>, c, <span class="string">&quot;post:CreateUser&quot;</span>)</span><br><span class="line">web.Run(<span class="string">&quot;:8081&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，定义了一个 UserController 结构体，这个 controller 组合了 beego 的 web controller，提供了获取用户和创建用户两个方法。然后注册路由的时候把这个 controller 传了进去。</p><p>也就是说，beego 是按照 MVC 模式设计的，它要求使用者在业务层面上使用 MVC 模式组织自己的代码，也就是一个业务一个 controller 这个样子。不过我个人觉得，这种设计不是很好，是否使用 MVC 应该让使用者自己选择，而不应该让框架提供者来左右。</p><p>再来看一下定义 controller 的时候组合的 beego 的 web controller 定义：</p><p><img src="https://zhyclouds.oss-cn-hangzhou.aliyuncs.com/haoyu/image-20250621212626372.png" alt="beego web controller"></p><p>这里有一个 ctx 字段，它的定义是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Context Http request context struct including BeegoInput, BeegoOutput, http.Request and http.ResponseWriter.</span></span><br><span class="line"><span class="comment">// BeegoInput and BeegoOutput provides an api to operate request and response more easily.</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">Input          *BeegoInput</span><br><span class="line">Output         *BeegoOutput</span><br><span class="line">Request        *http.Request</span><br><span class="line">ResponseWriter *Response</span><br><span class="line">_xsrfToken     <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，beego 在 ctx 里面存了请求和响应信息，以及自己的输入输出。我觉得这样有点重复了，很容易让使用者误解，为什么会有两个输入，两个输出，究竟应该使用哪个。</p><p>在启动 web 服务的时候，是直接使用的 web.Run 方法，这是 beego 提供的一个默认包变量，它的定义是：</p><p><img src="https://zhyclouds.oss-cn-hangzhou.aliyuncs.com/haoyu/image-20250621211358355.png" alt="beego server 抽象"></p><p>可以看到，beego 抽象出了一个 server 层面上的结构体，这个结构体里面有一些字段，其中 LifeCycleCallbacks 也就是声明周期回调函数，用户可以控制服务启动前干些什么，启动后干些什么。Server 字段是 http 包里面的 Server 类型，可以用来启动服务。Handlers 字段的类型定义是这样的：</p><p><img src="https://zhyclouds.oss-cn-hangzhou.aliyuncs.com/haoyu/image-20250621212145464.png" alt="controllerRegister"></p><p>这里面有一个 routers 字段，它是一个 map 类型，存的是每个请求方法对应的路由树，用户注册的路由会存到这里面来。</p><p>通过这些，可以看到 beego 基本上有四个抽象：</p><ul><li>路由（这个是最重要的）</li><li>server</li><li>context</li><li>controller</li></ul><p>server 负责把其它抽象组合起来，方便使用者使用，并且负责和 go 的 http 包打交道，在 server 层面上也提供了一些声明周期回调。</p><p>context 主要负责请求响应的传递，以及负责用户自定义的数据传递。</p><p>路由负责匹配请求和对应的业务处理方法。</p><p>controller 则负责业务处理。</p><p>整体样子就是：</p><img src="https://zhyclouds.oss-cn-hangzhou.aliyuncs.com/haoyu/%E7%BB%98%E5%9B%BE1.jpg" alt="beego 抽象" style="zoom: 13%;" /><h2 id="其它框架参考"><a href="#其它框架参考" class="headerlink" title="其它框架参考"></a>其它框架参考</h2><p>其它框架比如说 gin、iris、echo，用法上基本都相似，因为国内用 gin 也比较多嘛，所以这里以 gin 为例说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user_controller.go</span></span><br><span class="line"><span class="keyword">package</span> gin</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserController <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *UserController)</span></span> GetUser(ctx *gin.Context) &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;一些业务错误&quot;</span>)</span><br><span class="line">ctx.String(<span class="number">200</span>, <span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user_controller_test.go</span></span><br><span class="line"><span class="keyword">package</span> gin</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUserController_GetUser</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">g := gin.Default()</span><br><span class="line">ctrl := &amp;UserController&#123;&#125;</span><br><span class="line">g.GET(<span class="string">&quot;/user/info&quot;</span>, ctrl.GetUser)</span><br><span class="line">g.POST(<span class="string">&quot;/user/:param&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">ctx.String(http.StatusOK, <span class="string">&quot;hello %s&quot;</span>, <span class="string">&quot;world&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">_ = g.Run(<span class="string">&quot;:8082&quot;</span>)</span><br><span class="line"></span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:8083&quot;</span>, g)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，和 beego 不同的是 gin 没有按照 MVC 模式设计自己的代码，而是让用户在注册路由的时候，传入一个 <code>func(ctx *gin.Context)</code> 类型的函数，框架将其抽象成了<code>type HandlerFunc func(*Context)</code>。</p><p>这样的好处就是用户可以选择是否使用 MVC 模式来组织自己的代码。如果用户想要使用 MVC 模式，那么只需要按照这个函数类型设计自己的方法就可以了。</p><p>gin 的 Context 也和 beego 类似：</p><p><img src="https://zhyclouds.oss-cn-hangzhou.aliyuncs.com/haoyu/image-20250621220559357.png" alt="gin context"></p><p>至于 beego 的 httpServer，gin 里面是 Engine：</p><p><img src="https://zhyclouds.oss-cn-hangzhou.aliyuncs.com/haoyu/image-20250621220724817.png" alt="gin engine"></p><p>而且 gin 的 Engine，实现了 http 包里面的 Handler 接口：</p><p><img src="https://zhyclouds.oss-cn-hangzhou.aliyuncs.com/haoyu/image-20250621220854842.png" alt="gin engine"></p><p>也就意味着，我可以使用 gin 包提供的启动方法，也可以创建一个 gin 的 Engine，然后使用 http 包里面的 ListenAndServe 启动它。</p><p>然后 Engine 结构体组合了 RouterGroup，其定义为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RouterGroup is used internally to configure router, a RouterGroup is associated with</span></span><br><span class="line"><span class="comment">// a prefix and an array of handlers (middleware).</span></span><br><span class="line"><span class="keyword">type</span> RouterGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">Handlers HandlersChain</span><br><span class="line">basePath <span class="type">string</span></span><br><span class="line">engine   *Engine</span><br><span class="line">root     <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面存在和 Engine 的一个双向引用关系，gin 可能是需要在 RouterGroup 上拿到 engine 进行一些操作。</p><p>对于 gin 的路由注册：</p><p><img src="https://zhyclouds.oss-cn-hangzhou.aliyuncs.com/haoyu/image-20250621221250864.png" alt="gin router"></p><p>可以看到 gin 为不同的请求方法提供了不同的实现，不过最终都会调到 handle 方法上。这里我认为可以只提供一个 Handle 方法，不用提供 GET、POST 等这些实现，这样可以让接口尽可能的小而美。</p><p>可以看到 gin 也差不多设计成了这幅样子：</p><ul><li>Engine</li><li>路由 RouterGroup</li><li>Context</li><li>HandlerFunc</li></ul><p>和 beego 一样，只不过名字不用而已。</p><img src="https://zhyclouds.oss-cn-hangzhou.aliyuncs.com/haoyu/image-20250621221841238.png" alt="gin 抽象" style="zoom:13%;" /><p>其它几个框架类似，这里就不详细说了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以看到这些 web 框架，基本上都是一副鬼样子，有 server、路由、context、业务处理四个抽象。</p><p>server 负责和 go 的 http 包打交道，负责 web 服务的启动终止、生命周期管理，以及将路由注册、业务处理这些抽象组织在一起，方便框架者使用。</p><p>context 负责数据管理，请求响应内容处理。</p><p>业务处理负责组织使用者的业务代码。</p><p>路由注册负责绑定号好不同的请求方法和路径对应的业务处理逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> web 框架 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
